import pickle
import xgboost as xgb
import numpy as np
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import *


def main(x_train_padded_seqs, x_out_padded_seqs, labels, test_labels):
    # meta_train = np.zeros(shape=(len(x_train_padded_seqs), 2))
    meta_test = np.zeros(shape=(len(x_out_padded_seqs), 2))
    skf = StratifiedKFold(n_splits=5, random_state=4, shuffle=True)
    dout = xgb.DMatrix(x_out_padded_seqs)
    
    for i, (tr_ind, te_ind) in enumerate(skf.split(x_train_padded_seqs, labels)):
        # meta_test = np.zeros(shape=(len(x_out_padded_seqs), 2))
        print('FOLD: {}'.format(str(i)))
        X_train, X_train_label = x_train_padded_seqs[tr_ind], labels[tr_ind]
        X_val, X_val_label = x_train_padded_seqs[te_ind], labels[te_ind]
        dtrain = xgb.DMatrix(X_train, label=X_train_label)
        dtest = xgb.DMatrix(X_val, X_val_label)  # label可以不要，此处需要是为了测试效果

        param = {'max_depth': 6, 'eta': 0.01, 'eval_metric': 'mlogloss', 'silent': 1, 'objective': 'multi:softprob', 'nthread':10,
               'num_class': 2, 'subsample': 0.9,
                'colsample_bytree': 0.85, 'gpu_id': 0, 'tree_method': 'gpu_hist'}  # 参数
        evallist = [(dtrain, 'train'), (dtest, 'val')]  # 测试 , (dtrain, 'train')
        num_round = 50000  # 循环次数
        bst = xgb.train(param, dtrain, num_round, evallist, early_stopping_rounds=50)
        with open("xgbmodel"+"_{}".format(str(i+1))+".pkl","wb") as f:
            pickle.dump(bst, f)
            # bst = pickle.load(f)
        preds = bst.predict(dout)
        # for importance_type in ('weight', 'gain', 'cover', 'total_gain', 'total_cover'):
        #     print(bst.get_score(importance_type=importance_type))
        meta_test += preds
    meta_test /= 5.0
    # print(meta_test)
    out_pred_ = np.argmax(meta_test,axis=1)
    # test_df1.insert(0, "pred", out_pred_)
    # test_df1.to_csv("../data/test_df1.csv", index=False)
    print(test_labels)
    print(out_pred_)
    print(test_labels.shape)
    print(out_pred_.shape)
    acc = accuracy_score(test_labels, out_pred_)
    f1 = f1_score(test_labels, out_pred_, average='macro')
    pre = precision_score(test_labels, out_pred_, average='macro')
    rec = recall_score(test_labels, out_pred_, average='macro')
    print("混淆矩阵")
    print(confusion_matrix(test_labels, out_pred_))
    print("accuray: {}, f1score: {}, precision: {}, recall: {}".format(acc, f1, pre, rec))
    # break
